*******************************************************************************
                    Proposal for OpenGL support in MLT
*******************************************************************************


-------------------------------------------------------------------------------
                                Introduction
-------------------------------------------------------------------------------

The choosen design doesn't introduce any new dependency and requires
only a few additions in the MLT framework.

It begins with the introduction of a new image format,
"mlt_image_glsl", name: "glsl". (glsl was choosen to avoid confusion
with a possible later support of OpenCL.)

Then all OpenGL services and utils are embedded in a plugin (libmltopengl)
whose sources lie in the modules/opengl directory.


-------------------------------------------------------------------------------
								 Quick Start
-------------------------------------------------------------------------------

melt -profile atsc_1080p_25 -consumer xgl /path/to/file.mkv

(Note that you must set a profile, melt autoprofile would crash (until fixed)).
(The xgl consumer is really basic, no sound and a very simple speed control).


-------------------------------------------------------------------------------
                            Application Interface
-------------------------------------------------------------------------------

At run time, when the opengl plugin is loaded, mlt_repository_init 
sets a few global data properties:

"mlt_glsl_supported"
"mlt_glsl_init"
"mlt_glsl_get_texture"

These properties are pointers to functions called by the consumer/frontend
to turn opengl support on:

//////// Example /////////
mlt_properties gprop = mlt_global_properties();

int ( *glsl_supported )();
glsl_supported = mlt_properties_get_data( gprop, "mlt_glsl_supported", NULL );
int ( *glsl_init )( void*, void*, void* );
glsl_init = mlt_properties_get_data( gprop, "mlt_glsl_init", NULL );
unsigned int ( *glsl_get_texture )( void* );
glsl_get_texture = mlt_properties_get_data( gprop, "mlt_glsl_get_texture", NULL );

if ( glsl_supported && glsl_init && glsl_get_texture )
{
	// Ok, the opengl plugin is loaded
	// Now, check that our platform is supported
	if ( glsl_supported() )
	{
		// Yes, it is
		if ( glsl_init( (void*)bindctx_callback, (void*)unbindctx_callback, (void*)user_data )
		{
			// Ok, glsl is now initialized, we can start rendering.
			// See below for a description of glsl_init params and
			// how to use glsl_get_texture.
		}
	}
}
/////////////////////////

mlt_glsl_supported:
must be called with a valid opengl context bound to the calling thread.
This also apply to mlt_glsl_init.
Typically, it's called in your "initGL" function.
See mlt_glsl_supported() in mlt_glsl.c for the OpenGL requirements.

mlt_glsl_init:
this one requires some explanations.
OpenGL requires a so called context in order to execute any GL command.
An opengl context is typically associated to a drawable(window). Since OpenGL
is a cross platform API, it does not implement context creation but leaves
this to a companion API that is platform specific (e.g. GLX on Unix like OS).
A context must be bound to the thread where GL calls happen (e.g. by calling 
glxMakeCurrent in this thread). In addition, a context can only be bound to
one thread at a time, so it must be unbound in the first thread before
being bound in the second one. These context switchings have a cost,
that can become enormous under heavy load.
Fortunately, an application can create several context and bind each
to a different thread, and these context can share GL resources (such as textures).
A simple approach would be to have the consumer/frontend create its context
(used for display) and let MLT create its own (for rendering), shared with 
the app's one.
But that wouldn't work with toolkits where the OS specific context is not exposed
to the user (like in Qt that abstracts OS specific context in QGLContext).
That's why mlt_glsl_init takes pointers to make_current / done_current callbacks.
The consumer/frontend does create the 2 shared context and passes callbacks 
to mlt_glsl_init, together with a user_data pointer.
That might sound complicated but it's not. In Qt, it's as simple as
creating a second, hidden QGLWidget, shared with the main one, then pass
bind/unbind callbacks to mlt_glsl_init.

////////// Example //////////
void VideoWidget::hiddenMakeCurrent( void *userData ) /*static*/
{
	QGLWidget *w = (QGLWidget*)userData;
	w->makeCurrent();
}

void VideoWidget::hiddenDoneCurrent( void *userData ) /*static*/
{
	QGLWidget *w = (QGLWidget*)userData;
	w->doneCurrent();
}

void VideoWidget::initializeGL()
{
	// init stuff
	makeCurrent();
	glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );
	....
	....
	
	bool mltHasGlsl = false;
	hiddenctx = new QGLWidget( 0, this );
	if ( hiddenctx->isSharing() ) {
		if ( mlt_glsl_supported() ) {
			if ( mlt_glsl_init( (void*)hiddenMakeCurrent, (void*)hiddenDoneCurrent, (void*)&hiddenctx ) ) {
				// Good, glsl support initialized !
				mltHasGlsl = true;
			}
		}
	}
	if ( !mltHasGlsl ) {
		delete hiddenctx;
	}
	
	....
	....
}
/////////////////////////////

mlt_glsl_get_texture :
This function is called by the consumer/frontend to retrieve the texture name
associated with the image returned by mlt_frame_get_image.

//////////// Example ///////////////
mlt_image_format format = mlt_image_glsl;
int width = 0, height = 0;
uint8_t *image = NULL;
int error = mlt_frame_get_image( frame, &image, &format, &width, &height, 0 );
if ( !error && image )
	GLuint image_texture = mlt_glsl_get_texture( (void*)image );
///////////////////////////////////

Keep in mind that the texture is "released" (marked as free) as soon as the
frame is closed. So, it's strongly recommended to copy the image_texture and 
then use this copy for display instead of the image_texture itself. It also
has the advantage of making still image easy and clean, and if you need to
extract RGBA (e.g. with glReadPixels), this can be done in your main thread
with a PBO, and with most GPU it should happen in parallel to rendering 
(modern GPU have at least one dedicated, asynchronous, data transfer engine).

Note that opengl coordinates origin is bottom-left. mlt_glsl does not flip
images. You have to do it when displaying.

Note that it's strongly recommended to _not_ mix soft filters with glsl ones.
This would cause a huge performance penalty, and is not guaranteed to give
the expected result.


-------------------------------------------------------------------------------
                                   Internals
-------------------------------------------------------------------------------

When mlt_glsl_init successes, it creates an object of type glsl_env and
registers the pointer as a global data property called "glsl_env".
This property is checked in a number of places:
- In all glsl services init method. 
  If mlt_properties_get_data( mlt_global_properties(), "glsl_env", 0 )
  returns NULL, then the service initialization fails and returns NULL.
- In producer_loader_init.
  If mlt_properties_get_data( mlt_global_properties(), "glsl_env", 0 )
  returns non NULL, then the filter glsl.csc is created instead of 
  avcolor_space for color space conversion.
- In all glsl services get_image method, this pointer is retrieved with
  mlt_properties_get_data to access glsl internals. 


There is glsl versions for all normalisers:
- crop
- deinterlace : atm, only onefield and linearblend.
- rescaler : bilinear and bicubic. bicubic uses a catmullrom spline for 
  upscaling and a cos spline for downscaling. That's what i've found the best
  for my taste, but other splines can easily be added.
  See create_lut_texture in mlt_glsl.c
- fieldorder
- resizer


The color space conversion filter, glsl.csc, can convert any mlt format to 
glsl and glsl to any mlt format. However, it does not import or export alpha_mask.


Threading:
The current implementation is thread safe, so you should be able to assign any
value to real_time (see note1 below). All services must acquire the gl mutex
(g->context_lock()) before calling gl commands and release it 
(g->context_unlock()) when done. context_lock/unlock does two things, it 
locks/unlocks the mutex and bind/unbind the gl context.
(Note that calling mlt_frame_get_image _after_ context_lock would
trigger a deadlock.)
NOTE1: the xgl consumer defaults to real_time=0. real_time=1 works fine in most
cases, as long as the hardware (cpu+gpu) can decode/render in realtime. Else,
mlt starts alternating between synchronous and asynchronous and the gl context
is switched beetween the two threads => huge slowdown.
Ideally, mlt_glsl would have a threading model that keeps asynchronous rendering
while never switching to another thread. The gl context would be bound at
consumer_read_ahead_thread start and unbound at end. But i need help for this.
NOTE2: even with real_time=0, the gl context is bound/unbound a lot. This is not
a problem as long as it happens in the same thread (in this case, no context
switching happens) but it seems to trigger a bug. I've started devel on
kubuntu 10.04 where it worked as expected, then i've tested on an intel/mesa 
laptop running 11.10 and there i saw the bug: the XNextEvent call blocks, until
a new event enters the queue, so i had to continuously move the mouse over the
the consumer window (or hit keyboard keys). I've upgraded my desktop to 11.10
and got the same. I've then upgraded to beta 12.04 and there it works again,
only still some rare blocks in shotcut. I will try to further debbug this, but
the best would be to minimize glxMakeCurrent calls by implementing the 'ideal"
model.




-------------------------------------
Comments, suggestions and questions
are welcome through either mlt-devel
or directly at:
<Christophe Thommeret>hftom@free.fr
